{"version":3,"file":"main.js","sources":["../src/modules/Util.js","../src/modules/Serializer.js","../src/main.js"],"sourcesContent":["/**\n * Utility module\n * this module defines a bunch of utility functions that will be relevant to most other modules\n*/\nexport default {\n    /**\n     * tests if a variable is a DOCUMENT_NODE\n     *@param {*} node - node to test\n     *@returns {boolean}\n    */\n    isDocumentNode(node) {\n        return node && node.nodeType === 9;\n    },\n\n    /**\n     * tests if a variable is an ELEMENT_NODE\n     *@param {*} node - node to test\n     *@returns {boolean}\n    */\n    isElementNode(node) {\n        return node && node.nodeType === 1;\n    },\n\n    /**\n     * tests if a variable is an ATTRIBUTE_NODE\n     *@param {*} node - node to test\n     *@returns {boolean}\n    */\n    isAttributeNode(node) {\n        return node && (node.nodeType === 2 || Object.prototype.toString.call(node) === '[object Attr]');\n    },\n\n    /**\n     * tests if a variable is a TEXT_NODE\n     *@param {*} node - node to test\n     *@returns {boolean}\n    */\n    isTextNode(node) {\n        return node && node.nodeType === 3;\n    },\n\n    /**\n     * tests if a variable is a PROCESSING_INSTRUCTION_NODE\n     *@param {*} node - node to test\n     *@returns {boolean}\n    */\n    isProcessingInstructionNode(node) {\n        return node && node.nodeType === 7;\n    },\n\n    /**\n     * tests if a variable is a COMMENT_NODE\n     *@param {*} node - node to test\n     *@returns {boolean}\n    */\n    isCommentNode(node) {\n        return node && node.nodeType === 8;\n    },\n\n    /**\n     * tests if a variable is a DOCUMENT_TYPE_NODE\n     *@param {*} node - node to test\n     *@returns {boolean}\n    */\n    isDocTypeNode(node) {\n        return node && node.nodeType === 10;\n    },\n\n    /**\n     * tests if a variable is a DOM_FRAGMENT_NODE\n     *@param {*} node - node to test\n     *@returns {boolean}\n    */\n    isDOMFragmentNode(node) {\n        return node && node.nodeType === 11;\n    },\n};","import Util from './Util.js';\n\nconst XML_NS = 'http://www.w3.org/XML/1998/namespace',\nXMLNS_NS = 'http://www.w3.org/2000/xmlns/',\nHTML_NS = 'http://www.w3.org/1999/xhtml';\n\nexport default class Serializer {\n\n    /**\n     * creates an xml serializer\n     *@param {boolean} [preserveWhiteSpace=false] - boolean value indicating if it should preserve\n     * white spaces. defaults to false\n    */\n    constructor(preserveWhiteSpace) {\n        this.prefixIndex = 1;\n        this.dupPrefixDef = [];\n        this.preserveWhiteSpace = preserveWhiteSpace === false? false : true;\n    }\n\n    /**\n     * tests if the given text value is a valid xml name production\n     *@param {string} value - the text value\n     *@returns {boolean}\n    */\n    validateXMLNameProduction(value) {\n        let nameStart = '[a-z]|[:]|[_]|[\\\\u00C0-\\\\u00D6]|[\\\\u00D8-\\\\u00F6]|[\\\\u00F8-\\\\u02FF]|' +\n        '[\\\\u0370-\\\\u037D]|[\\\\u037F-\\\\u1FFF]|[\\\\u200C-\\\\u200D]|[\\\\u2070-\\\\u218F]|' +\n        '[\\\\u2C00-\\\\u2FEF]|[\\\\u3001-\\\\uD7FF]|[\\\\uF900-\\\\uFDCF]|[\\\\uFDF0-\\\\uFFFD]|' +\n        '[\\\\uD800-\\\\uDBFF]|[\\\\uDC00-\\\\uDFFF]',\n\n        nameChar = nameStart + '|[\\\\-]|[.]|[0-9]|\\\\u00B7|[\\\\u0300-\\\\u036F]|[\\\\u203F-\\\\u2040]';\n\n        let regex = new RegExp(`^(${nameStart})(${nameChar})*`, 'i');\n        return typeof value === 'string' && regex.test(value);\n    }\n\n    /**\n     * tests if the given text value is a valid xml tag name\n     *@param {string} value - the text value\n     *@returns {boolean}\n    */\n    validateXMLTagName(value) {\n        return this.validateXMLNameProduction(value) && !/^xml/i.test(value);\n    }\n\n    /**\n     * tests if the given text value is a valid xml attribute name\n     *@param {string} value - the text value\n     *@param {string} attrNS - attribute namespace value\n     *@returns {boolean}\n    */\n    validateXMLAttrName(value, attrNS) {\n        return this.validateXMLNameProduction(value) &&\n            (value.toLowerCase() !== 'xmlns' || attrNS !== null);\n    }\n\n    /**\n     * validates xml char\n     *@param {string} value - char to validate\n     *@returns {boolean}\n    */\n    validateChar(value) {\n        let char = '[\\\\u0009]|[\\\\u000A]|[\\\\u000D]|[\\\\u0020-\\uD7FF]|[\\\\uE000-\\\\uFFFD]|' +\n        '[\\\\uD800-\\\\uDBFF]|[\\\\uDC00-\\\\uDFFF]';\n\n        let regex = new RegExp(`^(${char})*$`);\n        return typeof value === 'string' && regex.test(value);\n    }\n\n    /**\n     * validates xml comment\n     *@param {string} comment - the xml comment\n     *@returns {boolean}\n    */\n    validateComment(comment) {\n        return this.validateChar(comment) && comment.indexOf('--') < 0 &&\n            comment.charAt(comment.length - 1) !== '-';\n    }\n\n    /**\n     * tests if the public id given is valid\n     *@param {string} pubId - the public id\n     *@returns {boolean}\n    */\n    validatePublicId(pubId) {\n        let pubIdChar = '[\\\\u0020]|[\\\\u000D]|[\\\\u000A]|[a-zA-Z0-9]|[\\\\-\\\\\\'()+,./:=?;!*#@$_%]';\n\n        let regex = new RegExp(`^(${pubIdChar})*$`);\n        return typeof pubId === 'string' && regex.test(pubId);\n    }\n\n    /**\n     * tests if the systemId given is valid\n     *@param {string} systemId - the systemId\n     *@returns {boolean}\n    */\n    validateSystemId(systemId) {\n        return this.validateChar(systemId);\n    }\n\n    /**\n     * validates xml processing instruction target value\n     *@param {string} target - the target text\n     *@returns {boolean}\n    */\n    validatePITarget(target) {\n        return this.validateChar(target) && target.indexOf(':') < 0 && target.toLowerCase() !== 'xml';\n    }\n\n    /**\n     * validates xml processing instruction data value\n     *@param {string} data - the data value\n     *@returns {boolean}\n    */\n    validatePIData(data) {\n        return this.validateChar(data) && data.indexOf('?>') < 0;\n    }\n\n    /**\n     * checks if the given tuple consisting of namespaceURI and localName pair exists in the records\n     *@param {Array} records - tuple records\n     *@param {Array} tuple - the tuple to check\n     *@returns {boolean}\n    */\n    tupleExists(records, tuple) {\n        let exists = false, len = tuple.length;\n        for (let record of records) {\n            if (len === record.length) {\n                exists = true;\n                let i = -1;\n                while (++i < len) {\n                    if (record[i] !== tuple[i]) {\n                        exists = false;\n                        break;\n                    }\n                }\n            }\n            if (exists)\n                break;\n        }\n        return exists;\n    }\n\n    /**\n     * generate a element prefix\n     *@param {Map} map - namespace prefix map,\n     *@param {string} ns - the new namespace\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-generate-prefix\n    */\n    generatePrefix(map, ns) {\n        let generatedPrefix = 'ns' + this.prefixIndex++;\n        map[ns] = generatedPrefix;\n\n        return generatedPrefix;\n    }\n\n    /**\n     * records the namespace information for an element\n     *@param {Element} elem - the element node\n     *@param {Map} prefixMap - element prefix to namespace map\n     *@param {Array} elmPrefixList - element current prefix list\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-record-namespace-info\n    */\n    recordElementNSInfo(elem, prefixMap, elmPrefixList) {\n        //STEP 1\n        let defNSAttrValue = null, attributes = elem.attributes, i = -1,\n        len = attributes.length;\n\n        //STEP 2\n        while (++i < len) {\n            //STEP 2. 1, 2\n            let attr = attributes[i], attrNS = attr.namespaceURI, attrPrefix = attr.prefix;\n            //STEP 2.3\n            if (attrNS === XMLNS_NS) {\n                //STEP 2.3.1\n                if (attrPrefix === null) {\n                    defNSAttrValue = attr.value;\n                    continue;\n                }\n\n                // STEP 2.3.2\n                //STEP 2.3.2.1 & 2.3.2.2\n                let prefixDef = attr.localName, nsDef = attr.value;\n\n                //STEP 2.3.2.3\n                if (typeof prefixMap[nsDef] !== 'undefined' && prefixMap[nsDef] === prefixDef)\n                    this.dupPrefixDef.push(prefixDef);\n\n                //STEP 2.3.2.4 & 2.3.2.5 combined\n                else\n                    prefixMap[nsDef] = prefixDef;\n\n                //STEP 2.3.3.6\n                elmPrefixList.push(prefixDef);\n            }\n        }\n        return defNSAttrValue;\n    }\n\n    /**\n     * serializes an attribute value given an attribute value and require well-formed flag\n     *@param {string} value - the attribute value\n     *@param {boolean} requireWellFormed - boolean value indicating if well formedness is a\n     * requirement\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-serialize-attr-value\n    */\n    serializeAttrValue(value, requireWellFormed) {\n        if (requireWellFormed && !this.validateChar(value))\n            throw new Error(value + ' is not a valid attribute value');\n\n        if (value === null)\n            return '';\n\n        return value.replace('\"', '&quot;').replace('&', '&amp;').replace('<', '&lt;')\n            .replace('>', '&gt;');\n    }\n\n    /**\n     * produces the XML serialization of the attributes of an element\n     *@param {Element} node - the element node\n     *@param {Map} map - namespace prefix map,\n     *@param {boolean} ignoreNSDefAttr - a boolean ignore namespace definition attribute flag,\n     *@param {string} dupPrefixDef - a duplicate prefix definition value\n     *@param {boolean} requireWellFormed - a boolean require well-formed xml flag\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-serialize-xml-attributes\n    */\n    serializeAttributes(node, map, ignoreNSDefAttr, requireWellFormed) {\n        //STEP 1, 2\n        let result = '', localNameSet = [];\n\n        let attributes = node.attributes, i = -1,\n        len = attributes.length;\n\n        //STEP 3\n        while (++i < len) {\n            let attr = attributes[i], nsURI = attr.namespaceURI, localName = attr.localName,\n            prefix = attr.prefix;\n\n            let tuple = [nsURI, localName];\n            //STEP 3.1\n            /* istanbul ignore if */\n            if (requireWellFormed && this.tupleExists(localNameSet, tuple))\n                throw new Error('element cannot have two attributes with the same namespaceURI and localName');\n\n            //STEP 3.2\n            localNameSet.push(tuple);\n\n            //STEP 3. 3, 4\n            let attrNS = nsURI, candidatePrefix = null;\n            //STEP 3.5\n            /* istanbul ignore else */\n            if (attrNS !== null) {\n                //STEP 3.5.1\n                if (attrNS === XMLNS_NS && ((prefix === null && ignoreNSDefAttr) ||\n                    (prefix !== null && this.dupPrefixDef.includes(localName)))) {\n                    continue;\n                }\n\n                else if (prefix === null) {\n                    candidatePrefix = null;\n                }\n\n                //STEP 3.5.2\n                else if (typeof map[attrNS] !== 'undefined') {\n                    candidatePrefix = map[attrNS];\n                }\n\n                //STEP 3.5.3\n                else {\n                    candidatePrefix = this.generatePrefix(map, attrNS);\n                    result += ` xmlns:${candidatePrefix}=\"${this.serializeAttrValue(attrNS)}\"`;\n                }\n            }\n\n            //STEP 3.6\n            result += ' ';\n\n            //STEP 3.7\n            if(candidatePrefix !== null)\n                result += candidatePrefix + ':';\n\n            //STEP 3.8\n            /* istanbul ignore if */\n            if (requireWellFormed && !this.validateXMLAttrName(localName, attrNS))\n                throw new Error(localName + ' is not a valid xml attribute name');\n\n            //STEP 3.9\n            result += `${localName}=\"${this.serializeAttrValue(attr.value)}\"`;\n        }\n\n        //STEP 4\n        return result;\n    }\n\n    /**\n     * serializes processing instruction node\n     *@param {ProcessingInstruction} node - the processing instruction node\n     *@param {boolean} requireWellFormed - boolean value indicating if well formedness is a\n     * requirement\n     *@returns {string}\n    */\n    serializeProcessingInstruction(node, requireWellFormed) {\n        //STEP 1\n        if (requireWellFormed && !this.validatePITarget(node.target))\n            throw new Error(node.target + ' is not a valid processing instruction target value');\n\n        //STEP 2\n        if (requireWellFormed && !this.validatePIData(node.data))\n            throw new Error(node.data + ' contains invalid processing instruction character values');\n\n        let target = this.preserveWhiteSpace? node.target : node.target.trim(),\n        data = this.preserveWhiteSpace? node.data : node.data.trim();\n        //STEP 4\n        let markup = `<?${target} ${data}?>`;\n\n        //STEP 4\n        return markup;\n    }\n\n    /**\n     * generate document type serialization\n     *@param {DocumentType} docType - the document type node\n     *@param {boolean} requireWellFormed - boolean value indicating if well formedness is a\n     * requirement\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-serialize-doctype\n    */\n    serializeDocumentType(docType, requireWellFormed) {\n        //STEP 1\n        if (requireWellFormed && !this.validatePublicId(docType.publicId))\n            throw new Error(docType.publicId + ' contains invalid xml document pubId character value');\n\n        //STEP 2\n        if (requireWellFormed && !this.validateSystemId(docType.systemId))\n            throw new Error(docType.systemId + ' contains invalid xml document systemId character value');\n\n        //STEP 3, 4, 5\n        let markup = '<!DOCTYPE ',\n        publicId = this.preserveWhiteSpace? docType.publicId : docType.publicId.trim(),\n        systemId = this.preserveWhiteSpace? docType.systemId : docType.systemId.trim();\n\n        if (publicId === '' && systemId === '' && /^html$/i.test(docType.name))\n            markup += docType.name.toLowerCase();\n        else\n            markup += docType.name;\n\n        //STEP 7\n        if (publicId !== '')\n            markup += ` PUBLIC \"${publicId}\"`;\n\n        //STEP 8\n        if (systemId !== '' && publicId === '')\n            markup += ` SYSTEM`;\n\n        //STEP 9\n        if (systemId !== '')\n            markup += ` \"${systemId}\"`;\n\n        //STEP 10\n        markup += '>';\n\n        return markup;\n    }\n\n    /**\n     * runs the XML serialization algorithm on a document fragment node\n     *@param {DocumentFragment} node - the document fragment node.\n     *@param {string} namespace - context namespace\n     *@param {Map} prefixMap - a namespace prefix map\n     *@param {boolean} requireWellFormed - a require well-formed flag\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-xml-serialization-algorithm\n    */\n    serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed) {\n        let markup = '', childNodes = node.childNodes, len = childNodes.length, i = -1;\n\n        while (++i < len) {\n            markup += this.runSerialization(childNodes[i], namespace, prefixMap, requireWellFormed);\n        }\n        return markup;\n    }\n\n    /**\n     * produces the XML serialization of a comment node\n     *@param {Text} node - the text node\n     *@param {boolean} requireWellFormed - a boolean require well-formed xml flag\n     *@returns {string}\n    */\n    serializeText(node, requireWellFormed) {\n        if(requireWellFormed && !this.validateChar(node.data))\n            throw new Error(node.data + ' is not a valid xml text data');\n\n        let data = this.preserveWhiteSpace? node.data : node.data.trim();\n        return data.replace(/\\&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n    }\n\n    /**\n     * produces the XML serialization of a comment node\n     *@param {Comment} node - the comment node\n     *@param {boolean} requireWellFormed - a boolean require well-formed xml flag\n     *@returns {string}\n    */\n    serializeComment(node, requireWellFormed) {\n        if(requireWellFormed && !this.validateComment(node.data))\n            throw new Error(node.data + ' is not a valid xml comment data');\n\n        return '<!--' + node.data + '-->';\n    }\n\n    /**\n     * runs the XML serialization algorithm on a document node\n     *@param {Element} node - the element node.\n     *@param {string} namespace - context namespace\n     *@param {Map} prefixMap - a namespace prefix map\n     *@param {boolean} requireWellFormed - a require well-formed flag\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-xml-serialization-algorithm\n    */\n    serializeDocument(node, namespace, prefixMap, requireWellFormed) {\n        if(requireWellFormed && node.documentElement === null)\n            throw new Error('document has no document element root');\n\n        let serializeDocument = `<?xml version=\"1.0\" encoding=\"${node.characterSet}\"?>`;\n\n        let childNodes = node.childNodes, len = childNodes.length, i = -1;\n\n        while (++i < len) {\n            serializeDocument += this.runSerialization(childNodes[i], namespace,\n                prefixMap, requireWellFormed);\n        }\n        return serializeDocument;\n    }\n\n    /**\n     * runs the XML serialization algorithm on an element node\n     *@param {Element} node - the element node.\n     *@param {string} namespace - context namespace\n     *@param {Map} prefixMap - a namespace prefix map\n     *@param {boolean} requireWellFormed - a require well-formed flag\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-xml-serialization-algorithm\n    */\n    serializeElement(node, namespace, prefixMap, requireWellFormed) {\n        let localName = node.localName; //get element local name\n\n        // STEP 1: if require well formed is true, and local name is not a valid xml tag name, throw error\n        /* istanbul ignore if */\n        if(requireWellFormed && !this.validateXMLTagName(localName))\n            throw new Error(localName + ' is not a valid xml element local name');\n\n        //STEP 2, 3, 4, 5, 6, 7\n        //declare markup, element qualified tag name, skip end tag boolean value, ignore\n        //namespace definition attribute, prefix map copy, element prefix list and\n        //duplicate prefix definition variables\n        let markup = '<', qualifiedName = '', skipEndTag = false, ignoreNSDefAttr = false,\n        map = Object.assign(Object.create(null), prefixMap), elmPrefixList = [];\n\n        //STEP 8\n        this.dupPrefixDef = [];\n\n        //STEP 9:\n        //get local definition namespace, update map copy and add any new element prefixes\n        let localDefNS = this.recordElementNSInfo(node, map, elmPrefixList, this.dupPrefixDef),\n\n        //STEP 10, 11\n        //delcare inherited namespace as parent namespace, and ns as node namespace uri\n        inheritedNS = namespace,\n        ns = node.namespaceURI;\n\n        //STEP 12\n        if(inheritedNS === ns) {\n            //STEP 12.1\n            /* istanbul ignore if */\n            if (localDefNS !== null)\n                ignoreNSDefAttr = true;\n\n            //STEP 12.2\n            /* istanbul ignore if */\n            if (ns === XML_NS)\n                qualifiedName = 'xml:' + localName;\n\n            //STEP 12.3\n            else\n                qualifiedName = localName;\n\n            //STEP 12.4\n            markup += qualifiedName;\n        }\n\n        //STEP 13\n        else {\n            //STEP 13. 1, 2\n            let prefix = node.prefix,\n            candidatePrefix = typeof map[ns] !== 'undefined'? map[ns] : null;\n\n            //STEP 13.3\n            /* istanbul ignore else */\n            if (candidatePrefix !== null) {\n                //STEP 13.3.1\n                qualifiedName = candidatePrefix + ':' + localName;\n\n                //STEP 13.3.2\n                /* istanbul ignore if */\n                if (localDefNS !== null)\n                    inheritedNS = ns;\n\n                //STEP 13.3.3\n                markup += qualifiedName;\n            }\n\n            //STEP 13.4\n            else if (prefix !== null && localDefNS === null) {\n                //STEP 13.4.1\n                if(elmPrefixList.includes(prefix)) {\n                    // it will use the prefixIndex instance variable. as js can't pass values by reference\n                    prefix = this.generatePrefix(map, ns);\n                }\n                //STEP 13.4.2\n                else {\n                    map[ns] = prefix;\n                }\n\n                //STEP 13.4.3\n                qualifiedName = prefix + ':' + localName;\n                //STEP 13.4.4\n                markup += qualifiedName;\n\n                //STEP 13.4.5. 1, 2, 3, 4, 5, 6\n                markup += ` xmlns:${prefix}=\"${this.serializeAttrValue(ns, requireWellFormed)}\"`;\n            }\n\n            //STEP 13.5\n            else if (localDefNS === null || localDefNS !== ns) {\n                //STEP 13.5. 1, 2, 3\n                ignoreNSDefAttr = true;\n                qualifiedName = localName;\n                inheritedNS = ns;\n\n                //STEP 13.5.4\n                markup += qualifiedName;\n\n                //STEP 13.5.5. 1, 2, 3, 4, 5, 6\n                markup += ` xmlns=\"${this.serializeAttrValue(ns, requireWellFormed)}\"`;\n            }\n\n            //STEP 13.6\n            else {\n                qualifiedName = localName;\n                inheritedNS = ns;\n                markup += qualifiedName;\n            }\n        }\n\n        //STEP 14\n        markup += this.serializeAttributes(node, map, ignoreNSDefAttr, requireWellFormed);\n\n        //STEP 15\n        if (ns === HTML_NS && !node.hasChildNodes() &&\n            /^(area|base|basefont|bgsound|br|col|embed|frame|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i.test(localName)) {\n            markup += ' /';\n            skipEndTag = true;\n        }\n\n        //STEP 16\n        if (ns !== HTML_NS && !node.hasChildNodes()) {\n            markup += '/';\n            skipEndTag = true;\n        }\n\n        //STEP 17\n        markup += '>';\n\n        //STEP 18\n        if (skipEndTag)\n            return markup;\n\n        //STEP 19\n        if (ns === HTML_NS && localName.toLowerCase() === 'template') {\n            markup += this.runSerialization(node.content, inheritedNS, map, requireWellFormed);\n        }\n\n        //STEP 20\n        else {\n            let len = node.childNodes.length, i = -1;\n            while (++i < len) {\n                markup += this.runSerialization(node.childNodes[i], inheritedNS, map, requireWellFormed);\n            }\n        }\n\n        //STEP 21\n        markup += '</' + qualifiedName + '>';\n\n        return markup;\n    }\n\n    /**\n     * runs the XML serialization algorithm on depending on the node type\n     *@param {Element} node - the element node.\n     *@param {string} contextNamespace - context namespace\n     *@param {Map} namespacePrefixes - a namespace prefix map\n     *@param {boolean} requireWellFormed - a require well-formed flag\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-serialize-xml\n    */\n    runSerialization(node, contextNamespace, namespacePrefixes, requireWellFormed) {\n        if (Util.isElementNode(node))\n            return this.serializeElement(node, contextNamespace, namespacePrefixes,\n                requireWellFormed);\n\n        if (Util.isDocumentNode(node))\n            return this.serializeDocument(node, contextNamespace, namespacePrefixes,\n                requireWellFormed);\n\n        if (Util.isCommentNode(node))\n            return this.serializeComment(node, requireWellFormed);\n\n        if (Util.isTextNode(node))\n            return this.serializeText(node, requireWellFormed);\n\n        if (Util.isDOMFragmentNode(node))\n            return this.serializeDocumentFragment(node, contextNamespace, namespacePrefixes,\n                requireWellFormed);\n\n        if(Util.isDocTypeNode(node))\n            return this.serializeDocumentType(node, requireWellFormed);\n\n        return this.serializeProcessingInstruction(node, requireWellFormed);\n    }\n\n    /**\n     * produces an XML serialization of root passing a value of false for the\n     * require well-formed parameter, and return the result.\n     *@see https://www.w3.org/TR/DOM-Parsing/#the-xmlserializer-interface\n     *@param {Node} root - the root node\n     *@param {boolean} [requireWellFormed=false] - boolean value indicating if it should require xml\n     * well formedness\n     *@returns {string}\n    */\n    serializeToString(root, requireWellFormed) {\n        //STEP 1, 2\n        let contextNamespace = null,\n        namespacePrefixes = Object.create(null); //use object.create to help support older browsers\n\n        //STEP 3\n        //initialize the namspace prefix with xml namspace\n        namespacePrefixes[XMLNS_NS] = 'xmlns';\n\n        //STEP 4\n        this.prefixIndex = 1;\n\n        requireWellFormed = requireWellFormed? true : false;\n\n        return this.runSerialization(root, contextNamespace, namespacePrefixes, requireWellFormed);\n    }\n}","import Serializer from './modules/Serializer.js';\n\nexport default class XMLSerializer {\n    /**\n     *@param {boolean} [preserveWhiteSpace=true] - boolean value indicating if white spaces\n     * should be preserved as it is in the source\n    */\n    constructor(preserveWhiteSpace) {\n        this.serializer = new Serializer(preserveWhiteSpace);\n    }\n\n    /**\n     * return XMLSerializer as modules name\n    */\n    get [Symbol.toStringTag]() {\n        return 'XMLSerializer';\n    }\n\n    /**\n     * produces an XML serialization of root passing a value of false for the\n     * require well-formed parameter, and return the result.\n     *@param {Node} root - the root node\n     *@param {boolean} [requireWellFormed=false] - boolean value indicating if it should require xml\n     * well formedness\n     *@returns {string}\n    */\n    serializeToString(root, requireWellFormed) {\n        return this.serializer.serializeToString(root, requireWellFormed);\n    }\n}"],"names":["isDocumentNode","node","nodeType","isElementNode","isAttributeNode","Object","prototype","toString","call","isTextNode","isProcessingInstructionNode","isCommentNode","isDocTypeNode","isDOMFragmentNode","XML_NS","XMLNS_NS","HTML_NS","Serializer","preserveWhiteSpace","prefixIndex","dupPrefixDef","value","nameStart","nameChar","regex","RegExp","test","validateXMLNameProduction","attrNS","toLowerCase","char","comment","validateChar","indexOf","charAt","length","pubId","pubIdChar","systemId","target","data","records","tuple","exists","len","record","i","map","ns","generatedPrefix","elem","prefixMap","elmPrefixList","defNSAttrValue","attributes","attr","namespaceURI","attrPrefix","prefix","prefixDef","localName","nsDef","push","requireWellFormed","Error","replace","ignoreNSDefAttr","result","localNameSet","nsURI","tupleExists","candidatePrefix","includes","generatePrefix","serializeAttrValue","validateXMLAttrName","validatePITarget","validatePIData","trim","markup","docType","validatePublicId","publicId","validateSystemId","name","namespace","childNodes","runSerialization","validateComment","documentElement","serializeDocument","characterSet","validateXMLTagName","qualifiedName","skipEndTag","assign","create","localDefNS","recordElementNSInfo","inheritedNS","serializeAttributes","hasChildNodes","content","contextNamespace","namespacePrefixes","Util","serializeElement","serializeComment","serializeText","serializeDocumentFragment","serializeDocumentType","serializeProcessingInstruction","root","XMLSerializer","serializer","serializeToString","Symbol","toStringTag"],"mappings":"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"}