{"version":3,"file":"main.min.js","sources":["../src/modules/Util.js","../src/modules/Serializer.js","../src/main.js"],"sourcesContent":["/**\n * Utility module\n * this module defines a bunch of utility functions that will be relevant to most other modules\n*/\nexport default {\n    /**\n     * tests if a variable is a DOCUMENT_NODE\n     *@param {*} node - node to test\n     *@returns {boolean}\n    */\n    isDocumentNode(node) {\n        return node && node.nodeType === 9;\n    },\n\n    /**\n     * tests if a variable is an ELEMENT_NODE\n     *@param {*} node - node to test\n     *@returns {boolean}\n    */\n    isElementNode(node) {\n        return node && node.nodeType === 1;\n    },\n\n    /**\n     * tests if a variable is an ATTRIBUTE_NODE\n     *@param {*} node - node to test\n     *@returns {boolean}\n    */\n    isAttributeNode(node) {\n        return node && (node.nodeType === 2 || Object.prototype.toString.call(node) === '[object Attr]');\n    },\n\n    /**\n     * tests if a variable is a TEXT_NODE\n     *@param {*} node - node to test\n     *@returns {boolean}\n    */\n    isTextNode(node) {\n        return node && node.nodeType === 3;\n    },\n\n    /**\n     * tests if a variable is a PROCESSING_INSTRUCTION_NODE\n     *@param {*} node - node to test\n     *@returns {boolean}\n    */\n    isProcessingInstructionNode(node) {\n        return node && node.nodeType === 7;\n    },\n\n    /**\n     * tests if a variable is a COMMENT_NODE\n     *@param {*} node - node to test\n     *@returns {boolean}\n    */\n    isCommentNode(node) {\n        return node && node.nodeType === 8;\n    },\n\n    /**\n     * tests if a variable is a DOCUMENT_TYPE_NODE\n     *@param {*} node - node to test\n     *@returns {boolean}\n    */\n    isDocTypeNode(node) {\n        return node && node.nodeType === 10;\n    },\n\n    /**\n     * tests if a variable is a DOM_FRAGMENT_NODE\n     *@param {*} node - node to test\n     *@returns {boolean}\n    */\n    isDOMFragmentNode(node) {\n        return node && node.nodeType === 11;\n    },\n};","import Util from './Util.js';\n\nconst XML_NS = 'http://www.w3.org/XML/1998/namespace',\nXMLNS_NS = 'http://www.w3.org/2000/xmlns/',\nHTML_NS = 'http://www.w3.org/1999/xhtml';\n\nexport default class Serializer {\n\n    /**\n     * creates an xml serializer\n     *@param {boolean} [preserveWhiteSpace=false] - boolean value indicating if it should preserve\n     * white spaces. defaults to false\n    */\n    constructor(preserveWhiteSpace) {\n        this.prefixIndex = 1;\n        this.dupPrefixDef = [];\n        this.preserveWhiteSpace = preserveWhiteSpace === false? false : true;\n    }\n\n    /**\n     * tests if the given text value is a valid xml name production\n     *@param {string} value - the text value\n     *@returns {boolean}\n    */\n    validateXMLNameProduction(value) {\n        let nameStart = '[a-z]|[:]|[_]|[\\\\u00C0-\\\\u00D6]|[\\\\u00D8-\\\\u00F6]|[\\\\u00F8-\\\\u02FF]|' +\n        '[\\\\u0370-\\\\u037D]|[\\\\u037F-\\\\u1FFF]|[\\\\u200C-\\\\u200D]|[\\\\u2070-\\\\u218F]|' +\n        '[\\\\u2C00-\\\\u2FEF]|[\\\\u3001-\\\\uD7FF]|[\\\\uF900-\\\\uFDCF]|[\\\\uFDF0-\\\\uFFFD]|' +\n        '[\\\\uD800-\\\\uDBFF]|[\\\\uDC00-\\\\uDFFF]',\n\n        nameChar = nameStart + '|[\\\\-]|[.]|[0-9]|\\\\u00B7|[\\\\u0300-\\\\u036F]|[\\\\u203F-\\\\u2040]';\n\n        let regex = new RegExp(`^(${nameStart})(${nameChar})*`, 'i');\n        return typeof value === 'string' && regex.test(value);\n    }\n\n    /**\n     * tests if the given text value is a valid xml tag name\n     *@param {string} value - the text value\n     *@returns {boolean}\n    */\n    validateXMLTagName(value) {\n        return this.validateXMLNameProduction(value) && !/^xml/i.test(value);\n    }\n\n    /**\n     * tests if the given text value is a valid xml attribute name\n     *@param {string} value - the text value\n     *@param {string} attrNS - attribute namespace value\n     *@returns {boolean}\n    */\n    validateXMLAttrName(value, attrNS) {\n        return this.validateXMLNameProduction(value) &&\n            (value.toLowerCase() !== 'xmlns' || attrNS !== null);\n    }\n\n    /**\n     * validates xml char\n     *@param {string} value - char to validate\n     *@returns {boolean}\n    */\n    validateChar(value) {\n        let char = '[\\\\u0009]|[\\\\u000A]|[\\\\u000D]|[\\\\u0020-\\uD7FF]|[\\\\uE000-\\\\uFFFD]|' +\n        '[\\\\uD800-\\\\uDBFF]|[\\\\uDC00-\\\\uDFFF]';\n\n        let regex = new RegExp(`^(${char})*$`);\n        return typeof value === 'string' && regex.test(value);\n    }\n\n    /**\n     * validates xml comment\n     *@param {string} comment - the xml comment\n     *@returns {boolean}\n    */\n    validateComment(comment) {\n        return this.validateChar(comment) && comment.indexOf('--') < 0 &&\n            comment.charAt(comment.length - 1) !== '-';\n    }\n\n    /**\n     * tests if the public id given is valid\n     *@param {string} pubId - the public id\n     *@returns {boolean}\n    */\n    validatePublicId(pubId) {\n        let pubIdChar = '[\\\\u0020]|[\\\\u000D]|[\\\\u000A]|[a-zA-Z0-9]|[\\\\-\\\\\\'()+,./:=?;!*#@$_%]';\n\n        let regex = new RegExp(`^(${pubIdChar})*$`);\n        return typeof pubId === 'string' && regex.test(pubId);\n    }\n\n    /**\n     * tests if the systemId given is valid\n     *@param {string} systemId - the systemId\n     *@returns {boolean}\n    */\n    validateSystemId(systemId) {\n        return this.validateChar(systemId);\n    }\n\n    /**\n     * validates xml processing instruction target value\n     *@param {string} target - the target text\n     *@returns {boolean}\n    */\n    validatePITarget(target) {\n        return this.validateChar(target) && target.indexOf(':') < 0 && target.toLowerCase() !== 'xml';\n    }\n\n    /**\n     * validates xml processing instruction data value\n     *@param {string} data - the data value\n     *@returns {boolean}\n    */\n    validatePIData(data) {\n        return this.validateChar(data) && data.indexOf('?>') < 0;\n    }\n\n    /**\n     * checks if the given tuple consisting of namespaceURI and localName pair exists in the records\n     *@param {Array} records - tuple records\n     *@param {Array} tuple - the tuple to check\n     *@returns {boolean}\n    */\n    tupleExists(records, tuple) {\n        let exists = false, len = tuple.length;\n        for (let record of records) {\n            if (len === record.length) {\n                exists = true;\n                let i = -1;\n                while (++i < len) {\n                    if (record[i] !== tuple[i]) {\n                        exists = false;\n                        break;\n                    }\n                }\n            }\n            if (exists)\n                break;\n        }\n        return exists;\n    }\n\n    /**\n     * generate a element prefix\n     *@param {Map} map - namespace prefix map,\n     *@param {string} ns - the new namespace\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-generate-prefix\n    */\n    generatePrefix(map, ns) {\n        let generatedPrefix = 'ns' + this.prefixIndex++;\n        map[ns] = generatedPrefix;\n\n        return generatedPrefix;\n    }\n\n    /**\n     * records the namespace information for an element\n     *@param {Element} elem - the element node\n     *@param {Map} prefixMap - element prefix to namespace map\n     *@param {Array} elmPrefixList - element current prefix list\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-record-namespace-info\n    */\n    recordElementNSInfo(elem, prefixMap, elmPrefixList) {\n        //STEP 1\n        let defNSAttrValue = null, attributes = elem.attributes, i = -1,\n        len = attributes.length;\n\n        //STEP 2\n        while (++i < len) {\n            //STEP 2. 1, 2\n            let attr = attributes[i], attrNS = attr.namespaceURI, attrPrefix = attr.prefix;\n            //STEP 2.3\n            if (attrNS === XMLNS_NS) {\n                //STEP 2.3.1\n                if (attrPrefix === null) {\n                    defNSAttrValue = attr.value;\n                    continue;\n                }\n\n                // STEP 2.3.2\n                //STEP 2.3.2.1 & 2.3.2.2\n                let prefixDef = attr.localName, nsDef = attr.value;\n\n                //STEP 2.3.2.3\n                if (typeof prefixMap[nsDef] !== 'undefined' && prefixMap[nsDef] === prefixDef)\n                    this.dupPrefixDef.push(prefixDef);\n\n                //STEP 2.3.2.4 & 2.3.2.5 combined\n                else\n                    prefixMap[nsDef] = prefixDef;\n\n                //STEP 2.3.3.6\n                elmPrefixList.push(prefixDef);\n            }\n        }\n        return defNSAttrValue;\n    }\n\n    /**\n     * serializes an attribute value given an attribute value and require well-formed flag\n     *@param {string} value - the attribute value\n     *@param {boolean} requireWellFormed - boolean value indicating if well formedness is a\n     * requirement\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-serialize-attr-value\n    */\n    serializeAttrValue(value, requireWellFormed) {\n        if (requireWellFormed && !this.validateChar(value))\n            throw new Error(value + ' is not a valid attribute value');\n\n        if (value === null)\n            return '';\n\n        return value.replace('\"', '&quot;').replace('&', '&amp;').replace('<', '&lt;')\n            .replace('>', '&gt;');\n    }\n\n    /**\n     * produces the XML serialization of the attributes of an element\n     *@param {Element} node - the element node\n     *@param {Map} map - namespace prefix map,\n     *@param {boolean} ignoreNSDefAttr - a boolean ignore namespace definition attribute flag,\n     *@param {string} dupPrefixDef - a duplicate prefix definition value\n     *@param {boolean} requireWellFormed - a boolean require well-formed xml flag\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-serialize-xml-attributes\n    */\n    serializeAttributes(node, map, ignoreNSDefAttr, requireWellFormed) {\n        //STEP 1, 2\n        let result = '', localNameSet = [];\n\n        let attributes = node.attributes, i = -1,\n        len = attributes.length;\n\n        //STEP 3\n        while (++i < len) {\n            let attr = attributes[i], nsURI = attr.namespaceURI, localName = attr.localName,\n            prefix = attr.prefix;\n\n            let tuple = [nsURI, localName];\n            //STEP 3.1\n            /* istanbul ignore if */\n            if (requireWellFormed && this.tupleExists(localNameSet, tuple))\n                throw new Error('element cannot have two attributes with the same namespaceURI and localName');\n\n            //STEP 3.2\n            localNameSet.push(tuple);\n\n            //STEP 3. 3, 4\n            let attrNS = nsURI, candidatePrefix = null;\n            //STEP 3.5\n            /* istanbul ignore else */\n            if (attrNS !== null) {\n                //STEP 3.5.1\n                if (attrNS === XMLNS_NS && ((prefix === null && ignoreNSDefAttr) ||\n                    (prefix !== null && this.dupPrefixDef.includes(localName)))) {\n                    continue;\n                }\n\n                else if (prefix === null) {\n                    candidatePrefix = null;\n                }\n\n                //STEP 3.5.2\n                else if (typeof map[attrNS] !== 'undefined') {\n                    candidatePrefix = map[attrNS];\n                }\n\n                //STEP 3.5.3\n                else {\n                    candidatePrefix = this.generatePrefix(map, attrNS);\n                    result += ` xmlns:${candidatePrefix}=\"${this.serializeAttrValue(attrNS)}\"`;\n                }\n            }\n\n            //STEP 3.6\n            result += ' ';\n\n            //STEP 3.7\n            if(candidatePrefix !== null)\n                result += candidatePrefix + ':';\n\n            //STEP 3.8\n            /* istanbul ignore if */\n            if (requireWellFormed && !this.validateXMLAttrName(localName, attrNS))\n                throw new Error(localName + ' is not a valid xml attribute name');\n\n            //STEP 3.9\n            result += `${localName}=\"${this.serializeAttrValue(attr.value)}\"`;\n        }\n\n        //STEP 4\n        return result;\n    }\n\n    /**\n     * serializes processing instruction node\n     *@param {ProcessingInstruction} node - the processing instruction node\n     *@param {boolean} requireWellFormed - boolean value indicating if well formedness is a\n     * requirement\n     *@returns {string}\n    */\n    serializeProcessingInstruction(node, requireWellFormed) {\n        //STEP 1\n        if (requireWellFormed && !this.validatePITarget(node.target))\n            throw new Error(node.target + ' is not a valid processing instruction target value');\n\n        //STEP 2\n        if (requireWellFormed && !this.validatePIData(node.data))\n            throw new Error(node.data + ' contains invalid processing instruction character values');\n\n        let target = this.preserveWhiteSpace? node.target : node.target.trim(),\n        data = this.preserveWhiteSpace? node.data : node.data.trim();\n        //STEP 4\n        let markup = `<?${target} ${data}?>`;\n\n        //STEP 4\n        return markup;\n    }\n\n    /**\n     * generate document type serialization\n     *@param {DocumentType} docType - the document type node\n     *@param {boolean} requireWellFormed - boolean value indicating if well formedness is a\n     * requirement\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-serialize-doctype\n    */\n    serializeDocumentType(docType, requireWellFormed) {\n        //STEP 1\n        if (requireWellFormed && !this.validatePublicId(docType.publicId))\n            throw new Error(docType.publicId + ' contains invalid xml document pubId character value');\n\n        //STEP 2\n        if (requireWellFormed && !this.validateSystemId(docType.systemId))\n            throw new Error(docType.systemId + ' contains invalid xml document systemId character value');\n\n        //STEP 3, 4, 5\n        let markup = '<!DOCTYPE ',\n        publicId = this.preserveWhiteSpace? docType.publicId : docType.publicId.trim(),\n        systemId = this.preserveWhiteSpace? docType.systemId : docType.systemId.trim();\n\n        if (publicId === '' && systemId === '' && /^html$/i.test(docType.name))\n            markup += docType.name.toLowerCase();\n        else\n            markup += docType.name;\n\n        //STEP 7\n        if (publicId !== '')\n            markup += ` PUBLIC \"${publicId}\"`;\n\n        //STEP 8\n        if (systemId !== '' && publicId === '')\n            markup += ` SYSTEM`;\n\n        //STEP 9\n        if (systemId !== '')\n            markup += ` \"${systemId}\"`;\n\n        //STEP 10\n        markup += '>';\n\n        return markup;\n    }\n\n    /**\n     * runs the XML serialization algorithm on a document fragment node\n     *@param {DocumentFragment} node - the document fragment node.\n     *@param {string} namespace - context namespace\n     *@param {Map} prefixMap - a namespace prefix map\n     *@param {boolean} requireWellFormed - a require well-formed flag\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-xml-serialization-algorithm\n    */\n    serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed) {\n        let markup = '', childNodes = node.childNodes, len = childNodes.length, i = -1;\n\n        while (++i < len) {\n            markup += this.runSerialization(childNodes[i], namespace, prefixMap, requireWellFormed);\n        }\n        return markup;\n    }\n\n    /**\n     * produces the XML serialization of a comment node\n     *@param {Text} node - the text node\n     *@param {boolean} requireWellFormed - a boolean require well-formed xml flag\n     *@returns {string}\n    */\n    serializeText(node, requireWellFormed) {\n        if(requireWellFormed && !this.validateChar(node.data))\n            throw new Error(node.data + ' is not a valid xml text data');\n\n        let data = this.preserveWhiteSpace? node.data : node.data.trim();\n        return data.replace(/\\&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n    }\n\n    /**\n     * produces the XML serialization of a comment node\n     *@param {Comment} node - the comment node\n     *@param {boolean} requireWellFormed - a boolean require well-formed xml flag\n     *@returns {string}\n    */\n    serializeComment(node, requireWellFormed) {\n        if(requireWellFormed && !this.validateComment(node.data))\n            throw new Error(node.data + ' is not a valid xml comment data');\n\n        return '<!--' + node.data + '-->';\n    }\n\n    /**\n     * runs the XML serialization algorithm on a document node\n     *@param {Element} node - the element node.\n     *@param {string} namespace - context namespace\n     *@param {Map} prefixMap - a namespace prefix map\n     *@param {boolean} requireWellFormed - a require well-formed flag\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-xml-serialization-algorithm\n    */\n    serializeDocument(node, namespace, prefixMap, requireWellFormed) {\n        if(requireWellFormed && node.documentElement === null)\n            throw new Error('document has no document element root');\n\n        let serializeDocument = `<?xml version=\"1.0\" encoding=\"${node.characterSet}\"?>`;\n\n        let childNodes = node.childNodes, len = childNodes.length, i = -1;\n\n        while (++i < len) {\n            serializeDocument += this.runSerialization(childNodes[i], namespace,\n                prefixMap, requireWellFormed);\n        }\n        return serializeDocument;\n    }\n\n    /**\n     * runs the XML serialization algorithm on an element node\n     *@param {Element} node - the element node.\n     *@param {string} namespace - context namespace\n     *@param {Map} prefixMap - a namespace prefix map\n     *@param {boolean} requireWellFormed - a require well-formed flag\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-xml-serialization-algorithm\n    */\n    serializeElement(node, namespace, prefixMap, requireWellFormed) {\n        let localName = node.localName; //get element local name\n\n        // STEP 1: if require well formed is true, and local name is not a valid xml tag name, throw error\n        /* istanbul ignore if */\n        if(requireWellFormed && !this.validateXMLTagName(localName))\n            throw new Error(localName + ' is not a valid xml element local name');\n\n        //STEP 2, 3, 4, 5, 6, 7\n        //declare markup, element qualified tag name, skip end tag boolean value, ignore\n        //namespace definition attribute, prefix map copy, element prefix list and\n        //duplicate prefix definition variables\n        let markup = '<', qualifiedName = '', skipEndTag = false, ignoreNSDefAttr = false,\n        map = Object.assign(Object.create(null), prefixMap), elmPrefixList = [];\n\n        //STEP 8\n        this.dupPrefixDef = [];\n\n        //STEP 9:\n        //get local definition namespace, update map copy and add any new element prefixes\n        let localDefNS = this.recordElementNSInfo(node, map, elmPrefixList, this.dupPrefixDef),\n\n        //STEP 10, 11\n        //delcare inherited namespace as parent namespace, and ns as node namespace uri\n        inheritedNS = namespace,\n        ns = node.namespaceURI;\n\n        //STEP 12\n        if(inheritedNS === ns) {\n            //STEP 12.1\n            /* istanbul ignore if */\n            if (localDefNS !== null)\n                ignoreNSDefAttr = true;\n\n            //STEP 12.2\n            /* istanbul ignore if */\n            if (ns === XML_NS)\n                qualifiedName = 'xml:' + localName;\n\n            //STEP 12.3\n            else\n                qualifiedName = localName;\n\n            //STEP 12.4\n            markup += qualifiedName;\n        }\n\n        //STEP 13\n        else {\n            //STEP 13. 1, 2\n            let prefix = node.prefix,\n            candidatePrefix = typeof map[ns] !== 'undefined'? map[ns] : null;\n\n            //STEP 13.3\n            /* istanbul ignore else */\n            if (candidatePrefix !== null) {\n                //STEP 13.3.1\n                qualifiedName = candidatePrefix + ':' + localName;\n\n                //STEP 13.3.2\n                /* istanbul ignore if */\n                if (localDefNS !== null)\n                    inheritedNS = ns;\n\n                //STEP 13.3.3\n                markup += qualifiedName;\n            }\n\n            //STEP 13.4\n            else if (prefix !== null && localDefNS === null) {\n                //STEP 13.4.1\n                if(elmPrefixList.includes(prefix)) {\n                    // it will use the prefixIndex instance variable. as js can't pass values by reference\n                    prefix = this.generatePrefix(map, ns);\n                }\n                //STEP 13.4.2\n                else {\n                    map[ns] = prefix;\n                }\n\n                //STEP 13.4.3\n                qualifiedName = prefix + ':' + localName;\n                //STEP 13.4.4\n                markup += qualifiedName;\n\n                //STEP 13.4.5. 1, 2, 3, 4, 5, 6\n                markup += ` xmlns:${prefix}=\"${this.serializeAttrValue(ns, requireWellFormed)}\"`;\n            }\n\n            //STEP 13.5\n            else if (localDefNS === null || localDefNS !== ns) {\n                //STEP 13.5. 1, 2, 3\n                ignoreNSDefAttr = true;\n                qualifiedName = localName;\n                inheritedNS = ns;\n\n                //STEP 13.5.4\n                markup += qualifiedName;\n\n                //STEP 13.5.5. 1, 2, 3, 4, 5, 6\n                markup += ` xmlns=\"${this.serializeAttrValue(ns, requireWellFormed)}\"`;\n            }\n\n            //STEP 13.6\n            else {\n                qualifiedName = localName;\n                inheritedNS = ns;\n                markup += qualifiedName;\n            }\n        }\n\n        //STEP 14\n        markup += this.serializeAttributes(node, map, ignoreNSDefAttr, requireWellFormed);\n\n        //STEP 15\n        if (ns === HTML_NS && !node.hasChildNodes() &&\n            /^(area|base|basefont|bgsound|br|col|embed|frame|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i.test(localName)) {\n            markup += ' /';\n            skipEndTag = true;\n        }\n\n        //STEP 16\n        if (ns !== HTML_NS && !node.hasChildNodes()) {\n            markup += '/';\n            skipEndTag = true;\n        }\n\n        //STEP 17\n        markup += '>';\n\n        //STEP 18\n        if (skipEndTag)\n            return markup;\n\n        //STEP 19\n        if (ns === HTML_NS && localName.toLowerCase() === 'template') {\n            markup += this.runSerialization(node.content, inheritedNS, map, requireWellFormed);\n        }\n\n        //STEP 20\n        else {\n            let len = node.childNodes.length, i = -1;\n            while (++i < len) {\n                markup += this.runSerialization(node.childNodes[i], inheritedNS, map, requireWellFormed);\n            }\n        }\n\n        //STEP 21\n        markup += '</' + qualifiedName + '>';\n\n        return markup;\n    }\n\n    /**\n     * runs the XML serialization algorithm on depending on the node type\n     *@param {Element} node - the element node.\n     *@param {string} contextNamespace - context namespace\n     *@param {Map} namespacePrefixes - a namespace prefix map\n     *@param {boolean} requireWellFormed - a require well-formed flag\n     *@returns {string}\n     *@see https://www.w3.org/TR/DOM-Parsing/#dfn-concept-serialize-xml\n    */\n    runSerialization(node, contextNamespace, namespacePrefixes, requireWellFormed) {\n        if (Util.isElementNode(node))\n            return this.serializeElement(node, contextNamespace, namespacePrefixes,\n                requireWellFormed);\n\n        if (Util.isDocumentNode(node))\n            return this.serializeDocument(node, contextNamespace, namespacePrefixes,\n                requireWellFormed);\n\n        if (Util.isCommentNode(node))\n            return this.serializeComment(node, requireWellFormed);\n\n        if (Util.isTextNode(node))\n            return this.serializeText(node, requireWellFormed);\n\n        if (Util.isDOMFragmentNode(node))\n            return this.serializeDocumentFragment(node, contextNamespace, namespacePrefixes,\n                requireWellFormed);\n\n        if(Util.isDocTypeNode(node))\n            return this.serializeDocumentType(node, requireWellFormed);\n\n        return this.serializeProcessingInstruction(node, requireWellFormed);\n    }\n\n    /**\n     * produces an XML serialization of root passing a value of false for the\n     * require well-formed parameter, and return the result.\n     *@see https://www.w3.org/TR/DOM-Parsing/#the-xmlserializer-interface\n     *@param {Node} root - the root node\n     *@param {boolean} [requireWellFormed=false] - boolean value indicating if it should require xml\n     * well formedness\n     *@returns {string}\n    */\n    serializeToString(root, requireWellFormed) {\n        //STEP 1, 2\n        let contextNamespace = null,\n        namespacePrefixes = Object.create(null); //use object.create to help support older browsers\n\n        //STEP 3\n        //initialize the namspace prefix with xml namspace\n        namespacePrefixes[XMLNS_NS] = 'xmlns';\n\n        //STEP 4\n        this.prefixIndex = 1;\n\n        requireWellFormed = requireWellFormed? true : false;\n\n        return this.runSerialization(root, contextNamespace, namespacePrefixes, requireWellFormed);\n    }\n}","import Serializer from './modules/Serializer.js';\n\nexport default class XMLSerializer {\n    /**\n     *@param {boolean} [preserveWhiteSpace=true] - boolean value indicating if white spaces\n     * should be preserved as it is in the source\n    */\n    constructor(preserveWhiteSpace) {\n        this.serializer = new Serializer(preserveWhiteSpace);\n    }\n\n    /**\n     * return XMLSerializer as modules name\n    */\n    get [Symbol.toStringTag]() {\n        return 'XMLSerializer';\n    }\n\n    /**\n     * produces an XML serialization of root passing a value of false for the\n     * require well-formed parameter, and return the result.\n     *@param {Node} root - the root node\n     *@param {boolean} [requireWellFormed=false] - boolean value indicating if it should require xml\n     * well formedness\n     *@returns {string}\n    */\n    serializeToString(root, requireWellFormed) {\n        return this.serializer.serializeToString(root, requireWellFormed);\n    }\n}"],"names":["node","nodeType","XMLNS_NS","HTML_NS","Serializer","preserveWhiteSpace","prefixIndex","dupPrefixDef","value","nameStart","regex","RegExp","test","this","validateXMLNameProduction","attrNS","toLowerCase","comment","validateChar","indexOf","charAt","length","pubId","systemId","target","data","records","tuple","exists","len","record","i","map","ns","generatedPrefix","elem","prefixMap","elmPrefixList","defNSAttrValue","attributes","attr","namespaceURI","attrPrefix","prefix","prefixDef","localName","nsDef","push","requireWellFormed","Error","replace","ignoreNSDefAttr","result","localNameSet","nsURI","tupleExists","candidatePrefix","includes","generatePrefix","serializeAttrValue","validateXMLAttrName","validatePITarget","validatePIData","trim","docType","validatePublicId","publicId","validateSystemId","markup","name","namespace","childNodes","runSerialization","validateComment","documentElement","serializeDocument","characterSet","validateXMLTagName","qualifiedName","skipEndTag","Object","assign","create","localDefNS","recordElementNSInfo","inheritedNS","serializeAttributes","hasChildNodes","content","contextNamespace","namespacePrefixes","Util","serializeElement","serializeComment","serializeText","serializeDocumentFragment","serializeDocumentType","serializeProcessingInstruction","root","serializer","serializeToString","Symbol","toStringTag"],"mappings":"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"}